// 1. 不考虑覆盖率的情况下，不需要使用 state 进行建模
// 2. comp 的函数允许修改数据，通过 comp 函数来记录 data 的最新值，更加灵活和简单，规范中通过 core lib 进行读写和记录，本质上就是全局函数
// 3. 不使用 home id，任意处理核进行访问，貌似效果是相同的

const bit[16] TotalTimes = 2;
const bit[16] CachelineTimes = 20;

const bit[16] NumCachelines = 2;

resource cacheline_r {}

struct cl_access_s {
  rand bit[8] offset;
  rand bit[8] size;

  constraint {
    size == 1 || size == 2 || size == 4 || size == 8 || size == 16 || size == 32 || size == 64;
    offset < 64;
    offset % size == 0;
  }
}

component CoherencyC {
  pool cacheline_r cl_r_pool;
  bind cl_r_pool *;

  bit[16] cl_idx;
  // 当前值
  bit[512] cl_val;

  // function void update_cl_val(bit[32] offset, bit[32] size, bit[512] val){
  // }

  action Init {
    rand bit[512] init_val;

    exec post_solve {
      comp.cl_val = init_val;
    }

    exec body c = """
    init_cl(CL_{{comp.cl_idx}}, 
    {{comp.cl_val[63:0]}}ul,
    {{comp.cl_val[127:64]}}ul,
    {{comp.cl_val[191:128]}}ul,
    {{comp.cl_val[255:192]}}ul,
    {{comp.cl_val[319:256]}}ul,
    {{comp.cl_val[383:320]}}ul,
    {{comp.cl_val[447:384]}}ul,
    {{comp.cl_val[511:448]}}ul
    );
    """;

    exec body sv = """
    exec.Init({{comp.cl_idx}}, {{comp.cl_val}});
    """;
  }

  action Write {
    rand bit[512] val;
    rand cl_access_s cl_access;
    rand executor_pkg::executor_claim_s core_claim;

    exec post_solve {
      // comp.update_cl_val(cl_access.offset, cl_access.size, val);
      if (cl_access.size == 1) {
        if (cl_access.offset == 0) {
          comp.cl_val [7:0] = val [7:0];
        } else if (cl_access.offset == 1) {
          comp.cl_val [15:8] = val [15:8];
        } else if (cl_access.offset == 2) {
          comp.cl_val [23:16] = val [23:16];
        } else if (cl_access.offset == 3) {
          comp.cl_val [31:24] = val [31:24];
        } else if (cl_access.offset == 4) {
          comp.cl_val [39:32] = val [39:32];
        } else if (cl_access.offset == 5) {
          comp.cl_val [47:40] = val [47:40];
        } else if (cl_access.offset == 6) {
          comp.cl_val [55:48] = val [55:48];
        } else if (cl_access.offset == 7) {
          comp.cl_val [63:56] = val [63:56];
        } else if (cl_access.offset == 8) {
          comp.cl_val [71:64] = val [71:64];
        } else if (cl_access.offset == 9) {
          comp.cl_val [79:72] = val [79:72];
        } else if (cl_access.offset == 10) {
          comp.cl_val [87:80] = val [87:80];
        } else if (cl_access.offset == 11) {
          comp.cl_val [95:88] = val [95:88];
        } else if (cl_access.offset == 12) {
          comp.cl_val [103:96] = val [103:96];
        } else if (cl_access.offset == 13) {
          comp.cl_val [111:104] = val [111:104];
        } else if (cl_access.offset == 14) {
          comp.cl_val [119:112] = val [119:112];
        } else if (cl_access.offset == 15) {
          comp.cl_val [127:120] = val [127:120];
        } else if (cl_access.offset == 16) {
          comp.cl_val [135:128] = val [135:128];
        } else if (cl_access.offset == 17) {
          comp.cl_val [143:136] = val [143:136];
        } else if (cl_access.offset == 18) {
          comp.cl_val [151:144] = val [151:144];
        } else if (cl_access.offset == 19) {
          comp.cl_val [159:152] = val [159:152];
        } else if (cl_access.offset == 20) {
          comp.cl_val [167:160] = val [167:160];
        } else if (cl_access.offset == 21) {
          comp.cl_val [175:168] = val [175:168];
        } else if (cl_access.offset == 22) {
          comp.cl_val [183:176] = val [183:176];
        } else if (cl_access.offset == 23) {
          comp.cl_val [191:184] = val [191:184];
        } else if (cl_access.offset == 24) {
          comp.cl_val [199:192] = val [199:192];
        } else if (cl_access.offset == 25) {
          comp.cl_val [207:200] = val [207:200];
        } else if (cl_access.offset == 26) {
          comp.cl_val [215:208] = val [215:208];
        } else if (cl_access.offset == 27) {
          comp.cl_val [223:216] = val [223:216];
        } else if (cl_access.offset == 28) {
          comp.cl_val [231:224] = val [231:224];
        } else if (cl_access.offset == 29) {
          comp.cl_val [239:232] = val [239:232];
        } else if (cl_access.offset == 30) {
          comp.cl_val [247:240] = val [247:240];
        } else if (cl_access.offset == 31) {
          comp.cl_val [255:248] = val [255:248];
        } else if (cl_access.offset == 32) {
          comp.cl_val [263:256] = val [263:256];
        } else if (cl_access.offset == 33) {
          comp.cl_val [271:264] = val [271:264];
        } else if (cl_access.offset == 34) {
          comp.cl_val [279:272] = val [279:272];
        } else if (cl_access.offset == 35) {
          comp.cl_val [287:280] = val [287:280];
        } else if (cl_access.offset == 36) {
          comp.cl_val [295:288] = val [295:288];
        } else if (cl_access.offset == 37) {
          comp.cl_val [303:296] = val [303:296];
        } else if (cl_access.offset == 38) {
          comp.cl_val [311:304] = val [311:304];
        } else if (cl_access.offset == 39) {
          comp.cl_val [319:312] = val [319:312];
        } else if (cl_access.offset == 40) {
          comp.cl_val [327:320] = val [327:320];
        } else if (cl_access.offset == 41) {
          comp.cl_val [335:328] = val [335:328];
        } else if (cl_access.offset == 42) {
          comp.cl_val [343:336] = val [343:336];
        } else if (cl_access.offset == 43) {
          comp.cl_val [351:344] = val [351:344];
        } else if (cl_access.offset == 44) {
          comp.cl_val [359:352] = val [359:352];
        } else if (cl_access.offset == 45) {
          comp.cl_val [367:360] = val [367:360];
        } else if (cl_access.offset == 46) {
          comp.cl_val [375:368] = val [375:368];
        } else if (cl_access.offset == 47) {
          comp.cl_val [383:376] = val [383:376];
        } else if (cl_access.offset == 48) {
          comp.cl_val [391:384] = val [391:384];
        } else if (cl_access.offset == 49) {
          comp.cl_val [399:392] = val [399:392];
        } else if (cl_access.offset == 50) {
          comp.cl_val [407:400] = val [407:400];
        } else if (cl_access.offset == 51) {
          comp.cl_val [415:408] = val [415:408];
        } else if (cl_access.offset == 52) {
          comp.cl_val [423:416] = val [423:416];
        } else if (cl_access.offset == 53) {
          comp.cl_val [431:424] = val [431:424];
        } else if (cl_access.offset == 54) {
          comp.cl_val [439:432] = val [439:432];
        } else if (cl_access.offset == 55) {
          comp.cl_val [447:440] = val [447:440];
        } else if (cl_access.offset == 56) {
          comp.cl_val [455:448] = val [455:448];
        } else if (cl_access.offset == 57) {
          comp.cl_val [463:456] = val [463:456];
        } else if (cl_access.offset == 58) {
          comp.cl_val [471:464] = val [471:464];
        } else if (cl_access.offset == 59) {
          comp.cl_val [479:472] = val [479:472];
        } else if (cl_access.offset == 60) {
          comp.cl_val [487:480] = val [487:480];
        } else if (cl_access.offset == 61) {
          comp.cl_val [495:488] = val [495:488];
        } else if (cl_access.offset == 62) {
          comp.cl_val [503:496] = val [503:496];
        } else if (cl_access.offset == 63) {
          comp.cl_val [511:504] = val [511:504];
        }
      } else if (cl_access.size == 2) {
        if (cl_access.offset == 0) {
          comp.cl_val [15:0] = val [15:0];
        } else if (cl_access.offset == 2) {
          comp.cl_val [31:16] = val [31:16];
        } else if (cl_access.offset == 4) {
          comp.cl_val [47:32] = val [47:32];
        } else if (cl_access.offset == 6) {
          comp.cl_val [63:48] = val [63:48];
        } else if (cl_access.offset == 8) {
          comp.cl_val [79:64] = val [79:64];
        } else if (cl_access.offset == 10) {
          comp.cl_val [95:80] = val [95:80];
        } else if (cl_access.offset == 12) {
          comp.cl_val [111:96] = val [111:96];
        } else if (cl_access.offset == 14) {
          comp.cl_val [127:112] = val [127:112];
        } else if (cl_access.offset == 16) {
          comp.cl_val [143:128] = val [143:128];
        } else if (cl_access.offset == 18) {
          comp.cl_val [159:144] = val [159:144];
        } else if (cl_access.offset == 20) {
          comp.cl_val [175:160] = val [175:160];
        } else if (cl_access.offset == 22) {
          comp.cl_val [191:176] = val [191:176];
        } else if (cl_access.offset == 24) {
          comp.cl_val [207:192] = val [207:192];
        } else if (cl_access.offset == 26) {
          comp.cl_val [223:208] = val [223:208];
        } else if (cl_access.offset == 28) {
          comp.cl_val [239:224] = val [239:224];
        } else if (cl_access.offset == 30) {
          comp.cl_val [255:240] = val [255:240];
        } else if (cl_access.offset == 32) {
          comp.cl_val [271:256] = val [271:256];
        } else if (cl_access.offset == 34) {
          comp.cl_val [287:272] = val [287:272];
        } else if (cl_access.offset == 36) {
          comp.cl_val [303:288] = val [303:288];
        } else if (cl_access.offset == 38) {
          comp.cl_val [319:304] = val [319:304];
        } else if (cl_access.offset == 40) {
          comp.cl_val [335:320] = val [335:320];
        } else if (cl_access.offset == 42) {
          comp.cl_val [351:336] = val [351:336];
        } else if (cl_access.offset == 44) {
          comp.cl_val [367:352] = val [367:352];
        } else if (cl_access.offset == 46) {
          comp.cl_val [383:368] = val [383:368];
        } else if (cl_access.offset == 48) {
          comp.cl_val [399:384] = val [399:384];
        } else if (cl_access.offset == 50) {
          comp.cl_val [415:400] = val [415:400];
        } else if (cl_access.offset == 52) {
          comp.cl_val [431:416] = val [431:416];
        } else if (cl_access.offset == 54) {
          comp.cl_val [447:432] = val [447:432];
        } else if (cl_access.offset == 56) {
          comp.cl_val [463:448] = val [463:448];
        } else if (cl_access.offset == 58) {
          comp.cl_val [479:464] = val [479:464];
        } else if (cl_access.offset == 60) {
          comp.cl_val [495:480] = val [495:480];
        } else if (cl_access.offset == 62) {
          comp.cl_val [511:496] = val [511:496];
        }
      } else if (cl_access.size == 4) {
        if (cl_access.offset == 0) {
          comp.cl_val [31:0] = val [31:0];
        } else if (cl_access.offset == 4) {
          comp.cl_val [63:32] = val [63:32];
        } else if (cl_access.offset == 8) {
          comp.cl_val [95:64] = val [95:64];
        } else if (cl_access.offset == 12) {
          comp.cl_val [127:96] = val [127:96];
        } else if (cl_access.offset == 16) {
          comp.cl_val [159:128] = val [159:128];
        } else if (cl_access.offset == 20) {
          comp.cl_val [191:160] = val [191:160];
        } else if (cl_access.offset == 24) {
          comp.cl_val [223:192] = val [223:192];
        } else if (cl_access.offset == 28) {
          comp.cl_val [255:224] = val [255:224];
        } else if (cl_access.offset == 32) {
          comp.cl_val [287:256] = val [287:256];
        } else if (cl_access.offset == 36) {
          comp.cl_val [319:288] = val [319:288];
        } else if (cl_access.offset == 40) {
          comp.cl_val [351:320] = val [351:320];
        } else if (cl_access.offset == 44) {
          comp.cl_val [383:352] = val [383:352];
        } else if (cl_access.offset == 48) {
          comp.cl_val [415:384] = val [415:384];
        } else if (cl_access.offset == 52) {
          comp.cl_val [447:416] = val [447:416];
        } else if (cl_access.offset == 56) {
          comp.cl_val [479:448] = val [479:448];
        } else if (cl_access.offset == 60) {
          comp.cl_val [511:480] = val [511:480];
        }
      } else if (cl_access.size == 8) {
        if (cl_access.offset == 0) {
          comp.cl_val [63:0] = val [63:0];
        } else if (cl_access.offset == 8) {
          comp.cl_val [127:64] = val [127:64];
        } else if (cl_access.offset == 16) {
          comp.cl_val [191:128] = val [191:128];
        } else if (cl_access.offset == 24) {
          comp.cl_val [255:192] = val [255:192];
        } else if (cl_access.offset == 32) {
          comp.cl_val [319:256] = val [319:256];
        } else if (cl_access.offset == 40) {
          comp.cl_val [383:320] = val [383:320];
        } else if (cl_access.offset == 48) {
          comp.cl_val [447:384] = val [447:384];
        } else if (cl_access.offset == 56) {
          comp.cl_val [511:448] = val [511:448];
        }
      } else if (cl_access.size == 16) {
        if (cl_access.offset == 0) {
          comp.cl_val [127:0] = val [127:0];
        } else if (cl_access.offset == 16) {
          comp.cl_val [255:128] = val [255:128];
        } else if (cl_access.offset == 32) {
          comp.cl_val [383:256] = val [383:256];
        } else if (cl_access.offset == 48) {
          comp.cl_val [511:384] = val [511:384];
        }
      } else if (cl_access.size == 32) {
        if (cl_access.offset == 0) {
          comp.cl_val [255:0] = val [255:0];
        } else if (cl_access.offset == 32) {
          comp.cl_val [511:256] = val [511:256];
        }
      } else if (cl_access.size == 64) {
        if (cl_access.offset == 0) {
          comp.cl_val [511:0] = val [511:0];
        }
      }
    }

    exec body c = """
    write_cl(CL_{{comp.cl_idx}}, {{cl_access.offset}}, {{cl_access.size}},
    {{comp.cl_val[63:0]}}ul,
    {{comp.cl_val[127:64]}}ul,
    {{comp.cl_val[191:128]}}ul,
    {{comp.cl_val[255:192]}}ul,
    {{comp.cl_val[319:256]}}ul,
    {{comp.cl_val[383:320]}}ul,
    {{comp.cl_val[447:384]}}ul,
    {{comp.cl_val[511:448]}}ul
    );
    """;
  }

  action Read {
    rand cl_access_s cl_access;
    rand executor_pkg::executor_claim_s core_claim;

    exec body c = """
    read_check_cl(CL_{{comp.cl_idx}}, {{cl_access.offset}}, {{cl_access.size}},
    {{comp.cl_val[63:0]}}ul,
    {{comp.cl_val[127:64]}}ul,
    {{comp.cl_val[191:128]}}ul,
    {{comp.cl_val[255:192]}}ul,
    {{comp.cl_val[319:256]}}ul,
    {{comp.cl_val[383:320]}}ul,
    {{comp.cl_val[447:384]}}ul,
    {{comp.cl_val[511:448]}}ul
    );
    """;
  }

  action DC {
    rand executor_pkg::executor_claim_s core_claim;

    exec body c = """
    dc_cl(CL_{{comp.cl_idx}});
    """;
  }

  action DmaWrite {
    exec body c = """
    dma_write_cl(CL_{{comp.cl_idx}}, 
    {{comp.cl_val[63:0]}}ul,
    {{comp.cl_val[127:64]}}ul,
    {{comp.cl_val[191:128]}}ul,
    {{comp.cl_val[255:192]}}ul,
    {{comp.cl_val[319:256]}}ul,
    {{comp.cl_val[383:320]}}ul,
    {{comp.cl_val[447:384]}}ul,
    {{comp.cl_val[511:448]}}ul
    );
    """;
  }

  action DmaRead {
    exec body c = """
    dma_read_check_cl(CL_{{comp.cl_idx}}, 
    {{comp.cl_val[63:0]}}ul,
    {{comp.cl_val[127:64]}}ul,
    {{comp.cl_val[191:128]}}ul,
    {{comp.cl_val[255:192]}}ul,
    {{comp.cl_val[319:256]}}ul,
    {{comp.cl_val[383:320]}}ul,
    {{comp.cl_val[447:384]}}ul,
    {{comp.cl_val[511:448]}}ul
    );
    """;
  }

  action TestCl {
    lock cacheline_r cl_r_lck;
    rand bit[32] home_cpu_id;

    constraint {
      home_cpu_id < ivy_app_cfg::NUM_CPUS;
    }

    activity {
      do Init;
      repeat (CachelineTimes) {
        select {
          // 区分 home cpu 和 snp cpu，提高相同 cpu 连续操作的概率
          
          // 本地cpu
          do Read with {core_claim.id == this.home_cpu_id;}
          do Write with {core_claim.id == this.home_cpu_id;}
          do DC with {core_claim.id == this.home_cpu_id;}
          // 其他 cpu
          do Read with {core_claim.id != this.home_cpu_id;}
          do Write with {core_claim.id != this.home_cpu_id;}
          do DC with {core_claim.id != this.home_cpu_id;}
          // dma 随便在哪个 cpu 上操作效果相同
          do DmaWrite;
          do DmaRead;
        }
      }
    }
  }
}

component Top {
  executor_pkg::executor_group_c core_executor_grp;
  executor_pkg::executor_c core_executor[ivy_app_cfg::NUM_CPUS];

  CoherencyC coherency_c[NumCachelines];

  exec init_down {
    repeat(i: NumCachelines) {
      coherency_c[i].cl_idx = i;
    }

    repeat(i: ivy_app_cfg::NUM_CPUS) {
      core_executor_grp.add_executor(core_executor[i]);
    }
  }

  action Entry {
    exec header c = """
    #include "mem_access.h"
    """;

    activity{
      repeat(TotalTimes){
        parallel {
          do CoherencyC::TestCl;
          do CoherencyC::TestCl;
        }
      }
    }
  }
}
